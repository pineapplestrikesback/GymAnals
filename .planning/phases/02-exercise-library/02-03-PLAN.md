---
phase: 02-exercise-library
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - GymAnals/Features/ExerciseLibrary/Views/ExerciseLibraryView.swift
  - GymAnals/Features/ExerciseLibrary/Views/ExerciseSearchResultsView.swift
  - GymAnals/Features/ExerciseLibrary/Views/ExerciseRow.swift
  - GymAnals/Features/ExerciseLibrary/ViewModels/ExerciseLibraryViewModel.swift
  - GymAnals/Features/ExerciseLibrary/Components/MuscleGroupFilterTabs.swift
  - GymAnals/Features/Dashboard/Views/DashboardTabView.swift
autonomous: true

must_haves:
  truths:
    - "User can browse a list of exercises from the library"
    - "User can filter exercises by muscle group using tabs"
    - "User can search exercises by name with debounced input"
    - "Search matches exercise name and target muscles"
    - "Starred and recent exercises appear at top of list"
  artifacts:
    - path: "GymAnals/Features/ExerciseLibrary/Views/ExerciseLibraryView.swift"
      provides: "Main exercise browse view with search and filter"
      contains: "struct ExerciseLibraryView"
    - path: "GymAnals/Features/ExerciseLibrary/Views/ExerciseSearchResultsView.swift"
      provides: "Subview with @Query for dynamic filtering"
      contains: "@Query private var exercises"
    - path: "GymAnals/Features/ExerciseLibrary/ViewModels/ExerciseLibraryViewModel.swift"
      provides: "Search state and debounce logic"
      contains: "debouncedSearchText"
  key_links:
    - from: "ExerciseLibraryView.swift"
      to: "ExerciseSearchResultsView.swift"
      via: "search parameters passed to subview init"
      pattern: "ExerciseSearchResultsView.*searchText.*muscleGroup"
    - from: "ExerciseSearchResultsView.swift"
      to: "Exercise model"
      via: "@Query with predicate"
      pattern: "#Predicate<Exercise>"
    - from: "DashboardTabView.swift"
      to: "ExerciseLibraryView.swift"
      via: "NavigationLink"
      pattern: "NavigationLink.*ExerciseLibraryView"
---

<objective>
Create the exercise library browse UI with search, filter, and muscle group tabs.

Purpose: Deliver EXER-05 (search/filter exercises) with a clean, performant UI using SwiftData subview pattern
Output: Exercise library view accessible from Dashboard, with muscle group filter tabs and debounced search
</objective>

<execution_context>
@/Users/opera_user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/opera_user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-exercise-library/02-CONTEXT.md
@.planning/phases/02-exercise-library/02-RESEARCH.md
@.planning/phases/02-exercise-library/02-01-SUMMARY.md
@.planning/phases/02-exercise-library/02-02-SUMMARY.md

@GymAnals/Models/Core/Exercise.swift
@GymAnals/Models/Core/Variant.swift
@GymAnals/Models/Enums/MuscleGroup.swift
@GymAnals/Features/Dashboard/Views/DashboardTabView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExerciseLibraryViewModel with debounced search</name>
  <files>GymAnals/Features/ExerciseLibrary/ViewModels/ExerciseLibraryViewModel.swift</files>
  <action>
Create ViewModel using Combine for debounce (per RESEARCH.md pattern):

```swift
import Foundation
import Combine

@Observable
final class ExerciseLibraryViewModel {
    var searchText: String = ""
    var debouncedSearchText: String = ""
    var selectedMuscleGroup: MuscleGroup? = nil

    private var cancellables = Set<AnyCancellable>()

    init() {
        // Debounce 300ms per CONTEXT.md spec
        // Note: @Observable doesn't have $ publisher, use didSet approach
    }
}
```

Since @Observable doesn't provide Combine publishers, use an alternative approach:

```swift
import Foundation
import SwiftUI

@Observable
final class ExerciseLibraryViewModel {
    var searchText: String = "" {
        didSet { scheduleDebounce() }
    }
    var debouncedSearchText: String = ""
    var selectedMuscleGroup: MuscleGroup? = nil

    private var debounceTask: Task<Void, Never>?

    private func scheduleDebounce() {
        debounceTask?.cancel()
        debounceTask = Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(300))
            guard !Task.isCancelled else { return }
            debouncedSearchText = searchText
        }
    }

    func clearSearch() {
        searchText = ""
        debouncedSearchText = ""
    }
}
```
  </action>
  <verify>Build succeeds</verify>
  <done>ViewModel handles search text with 300ms debounce, stores selected muscle group filter</done>
</task>

<task type="auto">
  <name>Task 2: Create ExerciseSearchResultsView with @Query subview pattern</name>
  <files>GymAnals/Features/ExerciseLibrary/Views/ExerciseSearchResultsView.swift, GymAnals/Features/ExerciseLibrary/Views/ExerciseRow.swift</files>
  <action>
**ExerciseSearchResultsView.swift** - Subview that constructs @Query from init parameters:

```swift
import SwiftUI
import SwiftData

struct ExerciseSearchResultsView: View {
    @Query private var exercises: [Exercise]

    init(searchText: String, muscleGroup: MuscleGroup?) {
        let muscleGroupRaw = muscleGroup?.rawValue

        _exercises = Query(
            filter: #Predicate<Exercise> { exercise in
                // Search filter (name contains search text)
                (searchText.isEmpty ||
                 exercise.variant?.name.localizedStandardContains(searchText) == true ||
                 exercise.variant?.movement?.name.localizedStandardContains(searchText) == true ||
                 exercise.equipment?.name.localizedStandardContains(searchText) == true) &&
                // Muscle group filter
                (muscleGroupRaw == nil ||
                 exercise.variant?.primaryMuscleGroupRaw == muscleGroupRaw)
            },
            sort: [
                SortDescriptor(\Exercise.isFavorite, order: .reverse),  // Starred first
                SortDescriptor(\Exercise.lastUsedDate, order: .reverse), // Recent next
                SortDescriptor(\Exercise.variant?.name)  // Alphabetical
            ]
        )
    }

    var body: some View {
        if exercises.isEmpty {
            ContentUnavailableView {
                Label("No Exercises", systemImage: "dumbbell")
            } description: {
                Text("No exercises match your search")
            }
        } else {
            List {
                // Starred/Recent section (first 10 with either)
                let featured = exercises.prefix(10).filter { $0.isFavorite || $0.lastUsedDate != nil }
                if !featured.isEmpty {
                    Section("Starred & Recent") {
                        ForEach(Array(featured)) { exercise in
                            ExerciseRow(exercise: exercise)
                        }
                    }
                }

                // All exercises
                Section("All Exercises") {
                    ForEach(exercises) { exercise in
                        ExerciseRow(exercise: exercise)
                    }
                }
            }
        }
    }
}
```

**ExerciseRow.swift:**

```swift
import SwiftUI

struct ExerciseRow: View {
    let exercise: Exercise

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(exercise.displayName)
                    .font(.body)

                if let muscles = exercise.variant?.primaryMuscleGroup?.displayName {
                    Text(muscles)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }

            Spacer()

            if exercise.isFavorite {
                Image(systemName: "star.fill")
                    .foregroundStyle(.yellow)
                    .font(.caption)
            }

            if !exercise.variant?.isBuiltIn ?? true {
                Text("Custom")
                    .font(.caption2)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.blue.opacity(0.1))
                    .clipShape(Capsule())
            }
        }
        .contentShape(Rectangle())
    }
}
```

Note: If @Query sorting by optional relationship causes issues, simplify to just alphabetical.
  </action>
  <verify>Build succeeds</verify>
  <done>ExerciseSearchResultsView uses subview pattern for dynamic @Query filtering</done>
</task>

<task type="auto">
  <name>Task 3: Create MuscleGroupFilterTabs and main ExerciseLibraryView</name>
  <files>GymAnals/Features/ExerciseLibrary/Components/MuscleGroupFilterTabs.swift, GymAnals/Features/ExerciseLibrary/Views/ExerciseLibraryView.swift, GymAnals/Features/Dashboard/Views/DashboardTabView.swift</files>
  <action>
**MuscleGroupFilterTabs.swift:**

```swift
import SwiftUI

struct MuscleGroupFilterTabs: View {
    @Binding var selectedGroup: MuscleGroup?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                FilterTab(title: "All", isSelected: selectedGroup == nil) {
                    selectedGroup = nil
                }

                ForEach(MuscleGroup.allCases) { group in
                    FilterTab(title: group.displayName, isSelected: selectedGroup == group) {
                        selectedGroup = group
                    }
                }
            }
            .padding(.horizontal)
        }
        .sensoryFeedback(.selection, trigger: selectedGroup)
    }
}

private struct FilterTab: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(isSelected ? Color.accentColor : Color.secondary.opacity(0.1))
                .foregroundStyle(isSelected ? .white : .primary)
                .clipShape(Capsule())
        }
        .buttonStyle(.plain)
    }
}
```

**ExerciseLibraryView.swift:**

```swift
import SwiftUI

struct ExerciseLibraryView: View {
    @State private var viewModel = ExerciseLibraryViewModel()

    var body: some View {
        VStack(spacing: 0) {
            // Muscle group filter tabs
            MuscleGroupFilterTabs(selectedGroup: $viewModel.selectedMuscleGroup)
                .padding(.vertical, 8)

            Divider()

            // Results view with debounced search
            ExerciseSearchResultsView(
                searchText: viewModel.debouncedSearchText,
                muscleGroup: viewModel.selectedMuscleGroup
            )
        }
        .navigationTitle("Exercises")
        .searchable(text: $viewModel.searchText, prompt: "Search exercises")
        .toolbar {
            ToolbarItem(placement: .primaryAction) {
                Button {
                    // TODO: Navigate to create exercise (Plan 02-05)
                } label: {
                    Image(systemName: "plus")
                }
            }
        }
    }
}

#Preview {
    NavigationStack {
        ExerciseLibraryView()
    }
    .modelContainer(PersistenceController.preview)
}
```

**DashboardTabView.swift update:**
Add NavigationLink to Exercises button that currently shows placeholder:

Find the LazyVGrid with buttons and update the "Exercises" button to navigate to ExerciseLibraryView:

```swift
NavigationLink {
    ExerciseLibraryView()
} label: {
    // existing label content
}
```
  </action>
  <verify>
1. Build succeeds
2. Run app, navigate to Dashboard tab, tap Exercises button -> opens ExerciseLibraryView
3. Filter tabs work, search debounces
  </verify>
  <done>Exercise library browse UI complete with filter tabs, debounced search, and navigation from Dashboard</done>
</task>

</tasks>

<verification>
1. `xcodebuild -scheme GymAnals -destination 'platform=iOS Simulator,name=iPhone 17' build` passes
2. App launches, exercises are visible in library
3. Muscle group tabs filter the list correctly
4. Search filters with 300ms debounce (no flicker while typing)
5. Starred exercises appear first when marked
</verification>

<success_criteria>
- User can browse exercise library from Dashboard
- Muscle group filter tabs work with haptic feedback
- Search filters by name with 300ms debounce
- Exercise list shows name, muscle group, starred/custom badges
- Empty state shown when no results match
</success_criteria>

<output>
After completion, create `.planning/phases/02-exercise-library/02-03-SUMMARY.md`
</output>
