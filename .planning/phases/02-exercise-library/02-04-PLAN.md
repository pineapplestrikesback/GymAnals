---
phase: 02-exercise-library
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - GymAnals/Features/ExerciseLibrary/Views/ExerciseDetailView.swift
  - GymAnals/Features/ExerciseLibrary/Views/MuscleWeightEditorView.swift
  - GymAnals/Features/ExerciseLibrary/Components/MuscleSlider.swift
  - GymAnals/Features/ExerciseLibrary/ViewModels/MuscleWeightViewModel.swift
  - GymAnals/Features/ExerciseLibrary/Views/ExerciseSearchResultsView.swift
autonomous: true

must_haves:
  truths:
    - "User can view exercise details including muscle contributions"
    - "User can edit muscle weights with 0.05 increment sliders"
    - "User can see which muscles are targeted by an exercise"
    - "Sliders have snap haptics at each increment"
    - "Changes are saved to SwiftData on confirmation"
  artifacts:
    - path: "GymAnals/Features/ExerciseLibrary/Views/ExerciseDetailView.swift"
      provides: "Exercise detail view with name, type, and muscle weights"
      contains: "struct ExerciseDetailView"
    - path: "GymAnals/Features/ExerciseLibrary/Views/MuscleWeightEditorView.swift"
      provides: "Collapsible list-based muscle weight editor"
      contains: "struct MuscleWeightEditorView"
    - path: "GymAnals/Features/ExerciseLibrary/Components/MuscleSlider.swift"
      provides: "Custom slider with 0.05 snap points and haptics"
      contains: "sensoryFeedback"
  key_links:
    - from: "ExerciseSearchResultsView.swift"
      to: "ExerciseDetailView.swift"
      via: "NavigationLink from row tap"
      pattern: "NavigationLink.*ExerciseDetailView"
    - from: "MuscleWeightEditorView.swift"
      to: "MuscleSlider.swift"
      via: "ForEach over muscles"
      pattern: "MuscleSlider"
    - from: "MuscleWeightEditorView.swift"
      to: "VariantMuscle model"
      via: "ModelContext for saving"
      pattern: "context.insert\\|context.save"
---

<objective>
Create exercise detail view and muscle weight editor with list-based interface.

Purpose: Deliver EXER-04 (view/edit weighted muscle contributions) with a list-based UI (3D model deferred to future enhancement)
Output: ExerciseDetailView showing exercise info, MuscleWeightEditorView with collapsible groups and snap sliders
</objective>

<execution_context>
@/Users/opera_user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/opera_user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-exercise-library/02-CONTEXT.md
@.planning/phases/02-exercise-library/02-RESEARCH.md
@.planning/phases/02-exercise-library/02-01-SUMMARY.md

@GymAnals/Models/Core/Exercise.swift
@GymAnals/Models/Core/Variant.swift
@GymAnals/Models/Core/VariantMuscle.swift
@GymAnals/Models/Enums/Muscle.swift
@GymAnals/Models/Enums/MuscleGroup.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MuscleSlider with snap haptics</name>
  <files>GymAnals/Features/ExerciseLibrary/Components/MuscleSlider.swift</files>
  <action>
Create a custom slider component with 0.05 increments and haptic feedback:

```swift
import SwiftUI

struct MuscleSlider: View {
    let muscle: Muscle
    @Binding var value: Double
    let isEditing: Bool

    // Track snap index for haptic trigger
    @State private var snapIndex: Int = 0

    // 0.05 increments = 21 levels (0, 0.05, 0.10... 1.0)
    private var displayValue: String {
        String(format: "%.2f", value)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(muscle.displayName)
                    .font(.subheadline)

                Spacer()

                Text(displayValue)
                    .font(.subheadline)
                    .monospacedDigit()
                    .foregroundStyle(value > 0 ? .primary : .secondary)
            }

            if isEditing {
                Slider(value: $value, in: 0...1, step: 0.05)
                    .sensoryFeedback(.impact(weight: .light), trigger: snapIndex)
                    .onChange(of: value) { oldValue, newValue in
                        let newIndex = Int(round(newValue / 0.05))
                        if newIndex != snapIndex {
                            snapIndex = newIndex
                        }
                    }
                    .tint(colorForWeight(value))
            } else {
                // Read-only progress bar
                GeometryReader { geometry in
                    ZStack(alignment: .leading) {
                        RoundedRectangle(cornerRadius: 2)
                            .fill(Color.secondary.opacity(0.2))
                            .frame(height: 4)

                        RoundedRectangle(cornerRadius: 2)
                            .fill(colorForWeight(value))
                            .frame(width: geometry.size.width * value, height: 4)
                    }
                }
                .frame(height: 4)
            }
        }
        .onAppear {
            snapIndex = Int(round(value / 0.05))
        }
    }

    private func colorForWeight(_ weight: Double) -> Color {
        switch weight {
        case 0.8...1.0: return .red
        case 0.5..<0.8: return .orange
        case 0.2..<0.5: return .yellow
        case 0.01..<0.2: return .green
        default: return .gray
        }
    }
}
```
  </action>
  <verify>Build succeeds</verify>
  <done>MuscleSlider component has 0.05 step increments with haptic feedback on snap points</done>
</task>

<task type="auto">
  <name>Task 2: Create MuscleWeightViewModel and MuscleWeightEditorView</name>
  <files>GymAnals/Features/ExerciseLibrary/ViewModels/MuscleWeightViewModel.swift, GymAnals/Features/ExerciseLibrary/Views/MuscleWeightEditorView.swift</files>
  <action>
**MuscleWeightViewModel.swift:**

```swift
import Foundation
import SwiftData

@Observable
final class MuscleWeightViewModel {
    var weights: [Muscle: Double] = [:]
    var isEditing: Bool = false
    var hasChanges: Bool = false

    private var originalWeights: [Muscle: Double] = [:]
    private let variant: Variant?

    init(variant: Variant?) {
        self.variant = variant
        loadWeights()
    }

    private func loadWeights() {
        guard let variant else { return }
        for vm in variant.muscleWeights {
            weights[vm.muscle] = vm.weight
        }
        originalWeights = weights
    }

    func updateWeight(muscle: Muscle, weight: Double) {
        weights[muscle] = weight
        hasChanges = weights != originalWeights
    }

    func saveChanges(context: ModelContext) {
        guard let variant, hasChanges else { return }

        // Remove existing weights
        for vm in variant.muscleWeights {
            context.delete(vm)
        }

        // Create new weights
        for (muscle, weight) in weights where weight > 0 {
            let vm = VariantMuscle(muscle: muscle, weight: weight)
            vm.variant = variant
            context.insert(vm)
        }

        // Update primary muscle group
        if let primary = weights.max(by: { $0.value < $1.value }) {
            variant.primaryMuscleGroupRaw = primary.key.group.rawValue
        }

        try? context.save()
        originalWeights = weights
        hasChanges = false
        isEditing = false
    }

    func discardChanges() {
        weights = originalWeights
        hasChanges = false
        isEditing = false
    }

    func undoAll() {
        weights = originalWeights
        hasChanges = false
    }

    func resetToDefault() {
        // For built-in exercises, this would restore original seed data
        // For now, clear all weights
        weights = [:]
        hasChanges = weights != originalWeights
    }
}
```

**MuscleWeightEditorView.swift:**

```swift
import SwiftUI
import SwiftData

struct MuscleWeightEditorView: View {
    @Environment(\.modelContext) private var modelContext
    @Bindable var viewModel: MuscleWeightViewModel
    @State private var expandedGroups: Set<MuscleGroup> = []

    var body: some View {
        List {
            // Assigned muscles section (muscles with weight > 0)
            let assigned = viewModel.weights.filter { $0.value > 0 }.sorted { $0.value > $1.value }
            if !assigned.isEmpty {
                Section("Targeted Muscles") {
                    ForEach(assigned, id: \.key) { muscle, weight in
                        MuscleSlider(
                            muscle: muscle,
                            value: binding(for: muscle),
                            isEditing: viewModel.isEditing
                        )
                    }
                }
            }

            // Collapsible muscle groups
            ForEach(MuscleGroup.allCases) { group in
                Section(isExpanded: expandedBinding(for: group)) {
                    ForEach(group.muscles) { muscle in
                        MuscleSlider(
                            muscle: muscle,
                            value: binding(for: muscle),
                            isEditing: viewModel.isEditing
                        )
                    }
                } header: {
                    HStack {
                        Text(group.displayName)
                        Spacer()
                        let groupTotal = group.muscles.reduce(0.0) { $0 + (viewModel.weights[$1] ?? 0) }
                        if groupTotal > 0 {
                            Text(String(format: "%.1f", groupTotal))
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            }
        }
        .listStyle(.insetGrouped)
        .toolbar {
            ToolbarItem(placement: .primaryAction) {
                if viewModel.isEditing {
                    Button("Done") {
                        viewModel.saveChanges(context: modelContext)
                    }
                } else {
                    Button("Edit") {
                        viewModel.isEditing = true
                    }
                }
            }

            if viewModel.isEditing && viewModel.hasChanges {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        viewModel.discardChanges()
                    }
                }
            }
        }
        .navigationTitle("Muscle Weights")
        .interactiveDismissDisabled(viewModel.hasChanges)
    }

    private func binding(for muscle: Muscle) -> Binding<Double> {
        Binding(
            get: { viewModel.weights[muscle] ?? 0 },
            set: { viewModel.updateWeight(muscle: muscle, weight: $0) }
        )
    }

    private func expandedBinding(for group: MuscleGroup) -> Binding<Bool> {
        Binding(
            get: { expandedGroups.contains(group) },
            set: { isExpanded in
                if isExpanded {
                    expandedGroups.insert(group)
                } else {
                    expandedGroups.remove(group)
                }
            }
        )
    }
}
```
  </action>
  <verify>Build succeeds</verify>
  <done>MuscleWeightEditorView shows assigned muscles at top, collapsible groups below, edit/save flow works</done>
</task>

<task type="auto">
  <name>Task 3: Create ExerciseDetailView and wire navigation</name>
  <files>GymAnals/Features/ExerciseLibrary/Views/ExerciseDetailView.swift, GymAnals/Features/ExerciseLibrary/Views/ExerciseSearchResultsView.swift</files>
  <action>
**ExerciseDetailView.swift:**

```swift
import SwiftUI
import SwiftData

struct ExerciseDetailView: View {
    @Environment(\.modelContext) private var modelContext
    let exercise: Exercise

    @State private var muscleViewModel: MuscleWeightViewModel?

    var body: some View {
        List {
            // Basic info section
            Section("Exercise Info") {
                LabeledContent("Name", value: exercise.displayName)

                if let equipment = exercise.equipment?.name {
                    LabeledContent("Equipment", value: equipment)
                }

                if let movement = exercise.variant?.movement {
                    LabeledContent("Type", value: movement.exerciseType.displayName)
                }

                Toggle("Favorite", isOn: favoriteBinding)
            }

            // Muscle targeting section
            Section {
                NavigationLink {
                    if let viewModel = muscleViewModel {
                        MuscleWeightEditorView(viewModel: viewModel)
                    }
                } label: {
                    HStack {
                        Text("Muscle Weights")
                        Spacer()
                        let count = exercise.variant?.muscleWeights.count ?? 0
                        Text("\(count) muscles")
                            .foregroundStyle(.secondary)
                    }
                }

                // Quick preview of top muscles
                if let variant = exercise.variant {
                    let topMuscles = variant.muscleWeights
                        .sorted { $0.weight > $1.weight }
                        .prefix(3)

                    ForEach(Array(topMuscles)) { vm in
                        HStack {
                            Text(vm.muscle.displayName)
                                .font(.subheadline)
                            Spacer()
                            Text(String(format: "%.0f%%", vm.weight * 100))
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            } header: {
                Text("Muscle Targeting")
            }

            // Info section for built-in vs custom
            if !(exercise.variant?.isBuiltIn ?? true) {
                Section {
                    Label("Custom Exercise", systemImage: "person.fill")
                        .foregroundStyle(.secondary)
                }
            }
        }
        .navigationTitle(exercise.displayName)
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            muscleViewModel = MuscleWeightViewModel(variant: exercise.variant)
        }
    }

    private var favoriteBinding: Binding<Bool> {
        Binding(
            get: { exercise.isFavorite },
            set: { newValue in
                exercise.isFavorite = newValue
                try? modelContext.save()
            }
        )
    }
}

#Preview {
    NavigationStack {
        ExerciseDetailView(exercise: Exercise())
    }
    .modelContainer(PersistenceController.preview)
}
```

**ExerciseSearchResultsView.swift update:**
Wrap ExerciseRow in NavigationLink:

Change the ForEach body from:
```swift
ExerciseRow(exercise: exercise)
```

To:
```swift
NavigationLink {
    ExerciseDetailView(exercise: exercise)
} label: {
    ExerciseRow(exercise: exercise)
}
```

Do this for both the Starred & Recent section and the All Exercises section.
  </action>
  <verify>
1. Build succeeds
2. Run app, tap exercise in library -> opens detail view
3. Tap Muscle Weights -> opens editor
4. Toggle Edit, adjust sliders (feel haptics), save
  </verify>
  <done>ExerciseDetailView shows exercise info, navigation to MuscleWeightEditorView works, editing flow complete</done>
</task>

</tasks>

<verification>
1. `xcodebuild -scheme GymAnals -destination 'platform=iOS Simulator,name=iPhone 17' build` passes
2. Tapping exercise in library opens detail view
3. Detail view shows name, equipment, type, and top muscles
4. Muscle Weights link opens editor with collapsible groups
5. Edit mode enables sliders with snap haptics
6. Save persists changes, Cancel discards
</verification>

<success_criteria>
- User can view exercise details with muscle contributions
- User can edit muscle weights using 0.05 increment sliders
- Sliders have light haptic feedback at snap points
- Assigned muscles appear at top of editor
- Changes are saved to SwiftData on Done tap
</success_criteria>

<output>
After completion, create `.planning/phases/02-exercise-library/02-04-SUMMARY.md`
</output>
