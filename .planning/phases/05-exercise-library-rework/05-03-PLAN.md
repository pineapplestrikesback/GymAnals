---
phase: 05-exercise-library-rework
plan: 03
type: execute
wave: 2
depends_on:
  - "01"
files_modified:
  - GymAnals/Models/Core/Equipment.swift
autonomous: true

must_haves:
  truths:
    - "Equipment model has id as String (not UUID)"
    - "Equipment model has embedded EquipmentProperties struct"
    - "Equipment model has categoryRaw stored property with computed accessor"
    - "Project compiles after Equipment update"
  artifacts:
    - path: "GymAnals/Models/Core/Equipment.swift"
      provides: "Updated Equipment model with category and properties"
      contains: "var properties: EquipmentProperties"
  key_links:
    - from: "Equipment.swift"
      to: "EquipmentCategory.swift"
      via: "categoryRaw stored property"
      pattern: "var categoryRaw: String"
    - from: "Equipment.swift"
      to: "EquipmentProperties.swift"
      via: "embedded struct"
      pattern: "var properties: EquipmentProperties"
---

<objective>
Update the Equipment model to support the new data schema with category and properties.

Purpose: Enable Equipment to store category classification and physical properties from equipment.json.
Output: Updated Equipment model ready for seeding 22 equipment types.
</objective>

<execution_context>
@/Users/opera_user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/opera_user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-exercise-library-rework/05-CONTEXT.md
@.planning/phases/05-exercise-library-rework/05-RESEARCH.md
@GymAnals/Models/Core/Equipment.swift
@GymAnals/Models/Enums/EquipmentCategory.swift
@GymAnals/Models/Embedded/EquipmentProperties.swift
@exercise_library_refactor/equipment.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Equipment model with new properties</name>
  <files>
    GymAnals/Models/Core/Equipment.swift
  </files>
  <action>
Update Equipment.swift to match the new schema:

```swift
import Foundation
import SwiftData

/// Equipment used for exercises (e.g., "Barbell", "Dumbbell", "Cable Machine")
@Model
final class Equipment {
    // MARK: - Identification

    /// Unique identifier - snake_case for built-in, UUID string for custom
    var id: String = UUID().uuidString

    /// Display name shown in UI
    var displayName: String = ""

    // MARK: - Classification

    /// Raw value storage for SwiftData predicate filtering
    var categoryRaw: String = EquipmentCategory.free_weight.rawValue

    /// Equipment physical properties (embedded struct)
    var properties: EquipmentProperties = EquipmentProperties()

    /// Notes about the equipment
    var notes: String = ""

    // MARK: - Metadata

    var isBuiltIn: Bool = true

    // MARK: - Relationships

    @Relationship(deleteRule: .cascade, inverse: \Exercise.equipment)
    var exercises: [Exercise] = []

    // MARK: - Computed Properties

    /// Type-safe access to equipment category
    var category: EquipmentCategory {
        get { EquipmentCategory(rawValue: categoryRaw) ?? .free_weight }
        set { categoryRaw = newValue.rawValue }
    }

    // MARK: - Initialization

    init(
        id: String? = nil,
        displayName: String,
        category: EquipmentCategory = .free_weight,
        properties: EquipmentProperties = EquipmentProperties(),
        notes: String = "",
        isBuiltIn: Bool = true
    ) {
        self.id = id ?? UUID().uuidString
        self.displayName = displayName
        self.categoryRaw = category.rawValue
        self.properties = properties
        self.notes = notes
        self.isBuiltIn = isBuiltIn
    }

    /// Convenience initializer for backward compatibility
    convenience init(name: String, isBuiltIn: Bool = true) {
        self.init(displayName: name, isBuiltIn: isBuiltIn)
    }
}
```

Key changes from old model:
1. Changed `id` from UUID to String (for snake_case built-in IDs)
2. Renamed `name` to `displayName` for consistency
3. Added `categoryRaw` with computed `category` accessor
4. Added `properties: EquipmentProperties` embedded struct
5. Added `notes` field
6. Added convenience init for backward compatibility with existing code
  </action>
  <verify>
Build project - should compile without errors. Existing code using Equipment(name:isBuiltIn:) should still work via convenience initializer.
  </verify>
  <done>
Equipment model updated with String id, displayName, category, properties, and notes. Backward-compatible initializer preserved.
  </done>
</task>

</tasks>

<verification>
1. Run `xcodebuild -scheme GymAnals -destination 'platform=iOS Simulator,name=iPhone 16' build` - exits with code 0
2. Equipment.swift contains "var id: String"
3. Equipment.swift contains "var categoryRaw: String"
4. Equipment.swift contains "var properties: EquipmentProperties"
5. Equipment.swift contains convenience init with (name:isBuiltIn:) signature
6. No compile errors in ExerciseSeedService or other files using Equipment
</verification>

<success_criteria>
- Equipment model compiles with all new properties
- String-based id allows snake_case identifiers for built-in equipment
- Embedded EquipmentProperties struct stored correctly
- Category enum accessible via computed property
- Existing code continues to compile via convenience initializer
</success_criteria>

<output>
After completion, create `.planning/phases/05-exercise-library-rework/05-03-SUMMARY.md`
</output>
