---
phase: 04-workout-logging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - GymAnals/Features/Workout/ViewModels/ActiveWorkoutViewModel.swift
autonomous: true

must_haves:
  truths:
    - "ViewModel loads existing active workout on init (crash recovery)"
    - "Starting workout creates and inserts Workout into context"
    - "Previous workout values are gym-specific"
    - "Exercise order tracks display sequence"
  artifacts:
    - path: "GymAnals/Features/Workout/ViewModels/ActiveWorkoutViewModel.swift"
      provides: "Active workout state management"
      exports: ["ActiveWorkoutViewModel"]
      min_lines: 150
  key_links:
    - from: "ActiveWorkoutViewModel"
      to: "ModelContext"
      via: "SwiftData operations"
      pattern: "modelContext\\.(insert|delete|fetch)"
---

<objective>
Create the ActiveWorkoutViewModel that manages all workout session state including exercises, sets, and previous workout lookups.

Purpose: This ViewModel is the core brain of the workout logging feature. It handles starting/finishing workouts, adding exercises, logging sets, and crash recovery through SwiftData auto-save.

Output: Fully functional ActiveWorkoutViewModel with workout lifecycle management, exercise ordering, and previous workout value retrieval.
</objective>

<execution_context>
@/Users/opera_user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/opera_user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-workout-logging/04-CONTEXT.md
@.planning/phases/04-workout-logging/04-RESEARCH.md
@GymAnals/Models/Core/Workout.swift
@GymAnals/Models/Core/WorkoutSet.swift
@GymAnals/Models/Core/Exercise.swift
@GymAnals/Models/Core/Gym.swift
@GymAnals/Features/Workout/ViewModels/GymSelectionViewModel.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ActiveWorkoutViewModel core structure</name>
  <files>
    GymAnals/Features/Workout/ViewModels/ActiveWorkoutViewModel.swift
  </files>
  <action>
Create ActiveWorkoutViewModel.swift following the existing ViewModel pattern (see GymSelectionViewModel):

```swift
@Observable
@MainActor
final class ActiveWorkoutViewModel {
    private let modelContext: ModelContext

    var activeWorkout: Workout?
    var exerciseOrder: [UUID] = []  // Exercise IDs in display order
    var expandedExercises: Set<UUID> = []  // Track collapsed state

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
        loadActiveWorkout()
    }
}
```

Implement `loadActiveWorkout()`:
- Query for workout where `isActive == true`
- If found, set `activeWorkout` and populate `exerciseOrder` from existing sets
- Expand all exercises by default
- Use uniqueExerciseIDs helper to extract ordered exercise IDs from sets (sorted by completedDate)

Implement `startWorkout(at gym: Gym?)`:
- Create new Workout with startDate: .now and provided gym
- Insert into modelContext
- Set as activeWorkout
- Clear exerciseOrder and expandedExercises

Implement `finishWorkout()`:
- Guard for activeWorkout existence
- Set `isActive = false`
- Set `endDate = .now`
- Clear activeWorkout, exerciseOrder, expandedExercises

Implement `discardWorkout()`:
- Guard for activeWorkout existence
- Delete workout from context (cascade deletes sets)
- Clear local state

Add helper `uniqueExerciseIDs(from sets: [WorkoutSet]) -> [UUID]`:
- Extract exercise IDs preserving first-appearance order
- Sort sets by completedDate first
  </action>
  <verify>Build succeeds. ViewModel initializes and can query for active workout.</verify>
  <done>ActiveWorkoutViewModel exists with workout lifecycle management (start, finish, discard) and crash recovery via loadActiveWorkout().</done>
</task>

<task type="auto">
  <name>Task 2: Add exercise and set management methods</name>
  <files>
    GymAnals/Features/Workout/ViewModels/ActiveWorkoutViewModel.swift
  </files>
  <action>
Add exercise management to ActiveWorkoutViewModel:

`func addExercise(_ exercise: Exercise)`:
- Guard activeWorkout exists
- Add exercise.id to exerciseOrder if not already present
- Add to expandedExercises (expanded by default)
- Update exercise.lastUsedDate = .now

`func removeExercise(_ exercise: Exercise)`:
- Remove from exerciseOrder
- Remove from expandedExercises
- Delete all workout sets for this exercise from current workout
- Do NOT delete the exercise itself

`func moveExercise(from source: IndexSet, to destination: Int)`:
- Reorder exerciseOrder array

`func toggleExerciseExpanded(_ exerciseID: UUID)`:
- Toggle presence in expandedExercises set

Add set management:

`func addSet(for exercise: Exercise) -> WorkoutSet`:
- Create new WorkoutSet with setNumber = (existing sets for this exercise).count + 1
- Pre-fill with previous workout values if available (call suggestedValues)
- Set workout and exercise relationships
- Insert into context
- Return the new set

`func deleteSet(_ set: WorkoutSet)`:
- Delete from context
- Renumber remaining sets for that exercise

`func setsForExercise(_ exercise: Exercise) -> [WorkoutSet]`:
- Return workout.sets filtered to this exercise, sorted by setNumber
  </action>
  <verify>Build succeeds. Methods compile correctly.</verify>
  <done>ViewModel can add/remove/reorder exercises, and add/delete sets with proper set numbering.</done>
</task>

<task type="auto">
  <name>Task 3: Add previous workout value lookup</name>
  <files>
    GymAnals/Features/Workout/ViewModels/ActiveWorkoutViewModel.swift
  </files>
  <action>
Add previous workout lookup methods to ActiveWorkoutViewModel:

`func previousSets(for exercise: Exercise) -> [WorkoutSet]`:
- Get current gym from activeWorkout?.gym
- Query completed workouts (isActive == false) at same gym, sorted by endDate descending
- Find first workout containing sets for this exercise
- Return those sets sorted by setNumber
- Return empty array if no previous workout found

`func suggestedValues(for exercise: Exercise, setNumber: Int) -> (reps: Int, weight: Double)?`:
- Call previousSets(for:)
- If setNumber <= previous.count, return that set's reps and weight
- Return nil if no previous data for this set number

`func previousSetForRow(exercise: Exercise, setNumber: Int) -> WorkoutSet?`:
- Convenience to get the actual previous WorkoutSet for display
- Returns nil if setNumber exceeds previous workout's set count

These methods support:
- Pre-filling values from previous workout (CONTEXT.md decision)
- Showing "last: 8x100" inline hints
- Gym-specific lookup (different gyms have different history)
  </action>
  <verify>Build succeeds. Previous workout lookup logic is correct.</verify>
  <done>ViewModel can look up previous workout values for any exercise/set, gym-specific, for pre-fill and inline hints.</done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -scheme GymAnals -destination 'platform=iOS Simulator,name=iPhone 16' build`
2. ActiveWorkoutViewModel initializes with ModelContext dependency
3. loadActiveWorkout() can find and restore an active workout
4. startWorkout() creates new Workout inserted into context
5. addSet() creates WorkoutSet with correct setNumber and pre-filled values
6. previousSets() returns gym-specific previous workout data
</verification>

<success_criteria>
- ViewModel follows established @Observable @MainActor pattern
- Workout lifecycle: start -> log sets -> finish OR discard
- Crash recovery: loadActiveWorkout() on init
- Previous values: gym-specific lookup for pre-fill and hints
- SwiftData auto-save handles persistence (no explicit save calls)
</success_criteria>

<output>
After completion, create `.planning/phases/04-workout-logging/04-02-SUMMARY.md`
</output>
